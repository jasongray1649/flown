#this program takes an input of 1s and 0s, then a row-separator character of your choice, which may not be 0, 1, 0x00 or 0xFF (newline is a good choice). It outputs infinitely many rows of 0x00 and 0xFF characters, separated by your specified row-separator, in accordance with rule 124, the horizontal reflection of rule 110 (see https://mathworld.wolfram.com/Rule110.html )
 
#rule 124, the horizontal reflection of rule 110 (and thus, is bounded on the lefthand side):
#111: 0
#110: 1
#101: 1
#100: 1
#011: 1
#010: 1
#001: 0
#000: 0
#For more information, see https://mathworld.wolfram.com/Rule110.html and https://en.wikipedia.org/wiki/Rule_110#Interesting_properties

#The internal encoding ("complex characters") is not as svelte as ideal, since we need to have an explicit end-of-the-universe marker that expands to the right at lightspeed for easy printing... otherwise we'd never know when to stop printing any given row of the automaton. At least the tape is full of 0s to start with, so we don't need to explicitly populate the eou.
# Internal symbol encoding: 
#blank blank: end-of-the-universe mark (eou)
#eof blank: 1
#blank eof: 0
#eof eof: beginning-of-the-universe mark
# The external encoding is just printing blank for 0 and eof for 1, also the user-supplied separator for the user-supplied separator, which is like encoding the eou. (BOU's are technically read, externally as 0's, but prompt special behavior to branch right.)

# Brief description of implementation:
# Program reads and translates input to internal encoding, then runs iterator, which reads, prints, overwrites, and rewrites updated encoding according to rule 124.
# Each iteration must write to right of old tape and replace old tape with BOU (eof eof), as there is no way to write blanks.
# Iterations will be separated by BOU's on right as they are written.
# Complexes are overwritten as they are read. Rightmost bit of triplet is always the cell read, excepting the initial read.
# This continues until leftmost bou is read, which is interpreted as a 0 and triggers the final two writes (and new rightmost bou) before printing the separator. 
# After separator is printed, and initial read begins again.

# Comments indicate current position of tape relative to two-cell complex using the following syntax:
# ( [x] x ) Where x can be e (known eof), b (known blank), ? (unknown character). Brackets indicate current position of tape, at that line. (For example, if a line reads "100 right #(? [?]), the comment indicates the tape's position AFTER "right" has been excecuted.)

#TODO: Finish iterator beyond initial read.
#TODO: Implement 

#read in the input (until a non-1-or-0 separator character is found)
10 in
11 out #debugging statement
#check it
20 if 0
21 go 30
22 if 1
23 go 30
25 go 50 # we found the separator, move on!
# advance input loop
30 right
31 go 10

#at this point it's e0110101010101[s]bbbbbb.

#initial BOU (eof eof)
#not strictly necessary but makes iterative logic consistent
50 right #immediate right of separator
55 in
60 right #right of first eof
65 in 
70 left # 0101010s[e]ebb
75 left # tapehead at separator 



#translate the input (loop always begins at separator)
#Go to left edge of tape. Read if 1 or 0, go to corresponding section.
100 left
110 if eof #found left edge of untranslated data
111 go 200
112 go 100 #loop

200 right #get on the first of the remaining input
210 if 1
220 go 300
230 if 0
240 go 400
249 #no input remaining
250 go 850 #on separator



300 # we've read a 1
310 in #OVERWRITE 1

#go right until the eou
#get to separator
320 right
321 if 1
322 go 320
323 if 0
324 go 320
325 #head at separator 
330 right #at first cell of complex

#check if eou
340 if blank #at first cell
341 go 370
350 right #(e ?) second cell
360 go 330

370 right #second cell
375 if blank #found eou
376 go 380
377 go 330 #found bou

380 left
381 in #write 1 (eb)
390 go 800
 


400 #we've read a 0
410 in #overwrite to keep our place for next time
#go right until the eou, making sure to skip over blanks in the 0-complexes

#get to separator
420 right
421 if 1
422 go 420 
430 if 0
431 go 420
435 right #at first cell of complex

#check if cell eou
440 if blank 
441 go 470
445 right
450 go 435

470 right #second cell
475 if blank #found eou
476 go 480
477 go 435

480 in #write 0 (be)
485 left #first cell
490 go 800




#DEBUG: Print then exit
#From anywhere, go right until separator, print twice, then print everything written so far until two eou's in a row are read.
#go right until blank (to ensure we are never left of separator)
500 right
505 if blank
510 go 520
515 go 500
520 left #left until special character
525 if blank
526 go 520
530 if eof
531 go 520
535 out #print separator (will get printed twice)
#right and print each cell until four blanks in a row are read. 
540 out
545 right
550 if eof
551 go 540
560 out #on blank
565 right
570 if eof
571 go 540
575 out #on second blank
580 right 
585 if eof
586 go 540
590 out # on third blank
595 right
600 if eof
601 go 540
610 out #on fourth blank
615 right 
620 if eof
621 go 540
630 go 9999 #EXIT






#we just translated a character at first (bb) on right 
#skip left until separator
800 left
801 if eof
802 go 800
803 if blank
804 go 800
810 #we must be at the separator   eeeee01[s]ee
820 go 100 #check if we've already translated every character

850 # on separator, all characters done, write bou at end

#right until eou
851 right #([?] ?)
852 if blank
853 go 870
854 right #(e [?])
855 go 851 
870 right #(b [?]) 
871 if eof
872 go 851

880 #(b [b]) found eou, write bou
881 in #(b [e])
882 left 
883 in #([e] e)
#translation and ending bou finished writing



#left until separator
900 left 
910 if eof
915 go 900
920 if blank
925 go 900
990 #on separator



999 right 
#PRINT LINE 
#starting on the left of a cell, parses and prints cells left to right, skipping bou (e e)

1000 if eof # ([?] ? )
1001 go 1020
1002 go 1030 

1020 right # (e [?]) 
1021 if eof #skip bou
1022 go 999
1024 left # ([e] b) 
1025 out #print 1
1026 right
1028 go 999

1030 right # (b [?]) 
1031 if blank #found eou
1032 go 1110
1035 left #first cell
1036 out #print 0
1037 right #second cell
1038 go 999

#go left until separator and print
1110 left
1120 if eof
1121 go 1110
1130 if blank
1131 go 1110
1140 out #print separator 
# 1150 go 500 DEBUG
# 1150 go 999 DEBUG INF LOOP

#print complete




#first read
1200 #from separator, go right until first 1 or 0
1201 right #([?] ?)
1210 if blank
1211 go 1250 
1215 right #(e [?])
1220 if eof #found bou (e [e])
1221 go 1201 #loop
#found 1
1229 # (e [b])
1230 in #overwrite
1235 right #start of next cell
1240 go 2100 #01?
#found 0
1250 right #(b [e])
1251 if blank #DEBUG
1252 go 500 #DEBUG error, (first blank should always be start of 0)
1260 left #([b] e)
1265 in #overwrite
1270 right #(e [e])
1271 right #start of next cell
1275 go 2000 #00?


#input is translated with bou at end, looks like esbb[1]010101beeee, tapehead on start of third complex (counting bou as first), second just overwritten
#third complex is read, overwritte, and appropriate digit is written on write
#tapehead goes left to bou, then to next bou. If next bou is immediate, write last two digits assuming next two reads are 0
#if next bou is not immediate, go to immediate right of bou and loop at 2X00

#ITERATOR 

#READ THIRD CELL
#Starting at first cell of third complex, check for 1 or 0 
#overwrite and send to appropriate next step

2000 #00? 
# ([?] ?)
2010 if blank 
2011 go 2030
2015 right #(e [?])
2017 if eof #error
2018 go 500
2020 in #(e [e])
2021 right #first cell on right
2025 go 3100 #001
2030 right #(b [?])
2035 if blank #error
2036 go 500
2040 left #([b] e)
2045 in #overwrite ([e] e)
2050 right
2055 right #first cell on right
2060 go 3000  #000
2099 go 9900

#01?
# ([?] ?)
2110 if blank 
2111 go 2130
2115 right #(e [?])
2117 if eof #error
2118 go 500
2120 in #(e [e])
2121 right #first cell on right
2125 go 3300 #011
2130 right #(b [?])
2135 if blank #error
2136 go 500
2140 left #([b] e)
2145 in #overwrite ([e] e)
2150 right
2155 right #first cell on right
2160 go 3200  #010
2199 go 9900

#10?
# ([?] ?)
2210 if blank 
2211 go 2230
2215 right #(e [?])
2217 if eof #error
2218 go 500
2220 in #(e [e])
2221 right #first cell on right
2225 go 3500 #101
2230 right #(b [?])
2235 if blank #error
2236 go 500
2240 left #([b] e)
2245 in #overwrite ([e] e)
2250 right
2255 right #first cell on right
2260 go 3400  #100
2299 go 9900

#11?
# ([?] ?)
2310 if blank 
2311 go 2330
2315 right #(e [?])
2317 if eof #error
2318 go 500
2320 in #(e [e])
2321 right #first cell on right
2325 go 3700 #111
2330 right #(b [?])
2335 if blank #error
2336 go 500
2340 left #([b] e)
2345 in #overwrite ([e] e)
2350 right
2355 right #first cell on right
2360 go 3600  #110
2399 go 9900


#WRITE & PRINT (0-50 is for normal cells, 50-100 is for eou and bou)
# 0, 1, 7 are 0. 2-6 are 1.
#starting on first cell last read complex
#goes right until first eou, writes appropriate numbers
#goes left until bou, then go left until next bou
#if next bou is immediate, go to appropriate 4x00
#if next bou is not immediate, go to first cell on right and loop at 2x000

3000 #000 (0)
#([?] ?) find eou
3001 if blank
3002 go 3006
3003 right
3004 right 
3005 go 3001
3006 if eof
3007 go 3004
3009 left #([b] b) found eou
3010 out #PRINT
3014 right #(b [e])
3015 in #WRITE
3016 left 
#left until first bou
3020 left # (? [?])
3021 if eof
3022 go 3027
3023 left 
3024 go 3020
3027 left # ([?] e)
3028 if blank
3029 go 3020
3040 left #(? [?]) found first bou
3041 if blank
3042 go 3049
3043 left #([?] e)
3044 if eof
3045 go 4000 #last write done
3046 go 3050
3049 left
3050 left #(? [?])
3051 if blank
3052 go 3049
3053 left #([?] e)
3054 if blank
3055 go 3050
3060 #found second bou
3065 right 
3070 right #([?] ?)
3075 go 2000


3100 #001 (0)
3200 #010 (1)
3300 #011 (1)
3400 #100 (1)
3500 #101 (1)
3600 #110 (1)
3700 #111 (0)


#if read two consecutive bou's in 3000's, stores last two digits read
#writes & prints appropriate last two digits
#then writes ending bou
#returns to separator and print
#loops back at 1200 at appropriate place in tape
4000 #00 (000 0, 000 0)
#([e] e)
4100 #01 (010 1, 100 1)
4200 #10 (100 1, 000 0)
4300 #11 (110 1, 100 1)

4500 #write ending bou
4600 #goto and print separator
4700 go 1200 #LOOP






#DEBUG, indicates reached end of program instead of exiting directly 
#right until any blank, then print 3 blank to indicate end (should see 3 blank then sep twice)
9900 if blank
9901 go 9910
9905 right
9906 go 9900
9910 out #blank
9911 out
9912 out 
9998 go 500 #print then exit if program gets to end